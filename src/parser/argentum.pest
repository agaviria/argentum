/// Argentum, a.k.a. (Silver) grammar using PEST.
// -------------------------------------------------
// |               PEST rules:                     |
// +-----------------------------------------------+
// pest matches white space by default ?           |
// _ silent rule                                   |
// @ atomic rule (no whitespace)                   |
// $ compund-atomic rule (don't generate tokens)   |
// ? optional                                      |
// ! not                                           |
// * 0 or more                                     |
// + 1 or more                                     |
// ~ followed by                                   |
// | or                                            |
// soi start of input                              |
// eoi end of input                                |
// any any character                               |
// ^ case insensitive (strings only)               |
// .. up to                                        |
// ------------------------------------------------/

// Top-level main rule.
top_lvl = { soi ~ (literal ~ statement)* ~ eoi }

// statement_old = { fn_dcl | dcl | (pexp ~ semi_colon) | comment } // statement
statement = { fn_dcl | (pexp ~ semi_colon) | comment } // statement

// Reserved Keywords
keyword_nil = {"nil"} // nil
keyword_cn  = {"const"} // constant
keyword_szo = {"sizeof"} // size info operator; determines the size of value type.
keyword_typ = {"typeof"} // type info operator; determines the system value type.

// Keyword "volatile", specifies a field which may be modified by an external
// process and prevents an optimizing compiler from modifying the use of the field.
keyword_vl = {"volatile"}

alpha         = _{ 'a'..'z' | 'A'..'Z' } // Alphabet
identifier    = _{ (alpha | "_") ~ (alpha | digit)* }
ident_literal = @{ !bool_literal ~ identifier }
const_literal = @{ 'A'..'Z' ~ (alpha | digit)* }

// Declarations
arg_dcl = { ident_literal ~ type_dcl } // single argument declaration

// args_dcl_old = { arg_dcl ~ (comma ~  arg_dcl)* | arg_dcl? } // multiple arguments

args_dcl = { arg_dcl? ~ (arg_dcl ~ comma)* } // zero or multiple arguments
type_dcl = { dcl_type_op ~ prim_type } // literal type declaration
dcl = { "let" ~ ident_literal ~ type_dcl? ~ pexp? ~ semi_colon } // declaration

fn_call = { lparen ~ args_dcl? ~ rparen }

// function declaration
fn_dcl_old = { "fn" ~ ident_literal ~ fn_call ~ (cast_op ~ type_dcl)? ~ code_block* }

fn_dcl = { "fn" ~ ident_literal ~ lparen ~ (arg_dcl ~ comma)* ~ arg_dcl? ~ rparen ~ (cast_op ~ prim_type)? ~ lbrace ~ (!fn_dcl ~ statement)* ~ rbrace }

code_block = _{ lbrace ~ (!fn_dcl ~ statement)* ~ pexp ~ rbrace }

// Single character tokens
lparen      = _{"("} // left parenthese
rparen      = _{")"} // right parenthese
lbrace      = _{"{"} // left brace
rbrace      = _{"}"} // right brace
lsq         = _{"["} // left square bracket
rsq         = _{"["} // right square bracket
comma       = _{","} // comma operator
dot         = _{"."} // dot operator
semi_colon  = _{";"} // semi-colon operator
expoll_op   = _{"?"} // exception poll operator
ptr_op      = {"*"} // pointer operator
addr_op     = {"&"} // address operator
deref_op    = {"*"} // de-reference operator
plus        = {"+"} // plus
minus       = {"-"} // minus
bwcom_op    = {"~"} // bit wise complement operator, inverts binary rep of an exp.
arr_inc_op  = {"+"} // array increment operator
dcl_type_op = {":"} // declare type operator

// Arithmetic operators
add_op  = {"+"}
sub_op  = {"-"}
mult_op = {"*"}
div_op  = {"/"}
mod_op  = {"%"}

plus_elect_op   = {"+="} // add on elect operator
minus_elect_op  = {"-="} // subtract on elect operator
multi_elect_op  = {"*="} // multiply on elect operator
div_elect_op    = {"/="} // divide on elect operator
mod_elect_op    = {"%="} // modulus on elect operator
lshft_elect_op  = {"<<="} // left shift elect operator
rshft_elect_op  = {">>="} // right shift elect operator
bw_or_elect_op  = {"|="} // bit-wise or, on elect operator
bw_and_elect_op = {"&="} // bit-wise and, on elect operator
bw_xor_elect_op = {"^="} // bit-wise exclusive or, on operator

qwt             = _{"\""} // quote (")
sqwt            = _{"'"} // single quote (')

// One or two character tokens
elect_op = {"="} // elect operator
expnt_op = {"**"} // exponent operator
inc_op   = {"++"} // increment operator
dec_op   = {"--"} // decrement operator
not_op   = {"!"} // negate boolean operator
eq_op    = {"=="} // equal operator
neq_op   = {"!="} // not equal operator
gt_op    = {">"} // greater than operator
gt_eq_op  = {">="} // greater than or equal operator
lt_op    = {"<"} // less than operator
lt_eq_op  = {"<="} // less than or equal operator
lshft_op = {"<<"} // left shift operator
rshft_op = {">>"} // right shift operator
rng_op   = { ".." } // range operator
cast_op  = {"->"} // cast operator
bwand_op = {"&"} // bit wise and operator
bwor_op  = {"|"} // bit wise or operator
bwxor_op = {"^"} // bit wise exclusive or operator

and_op   = {"&&"} // logical and operator
or_op    = {"||"} // logical or operator

binary_op = _{
  expnt_op |
  mult_op  |
  div_op   |
  mod_op   |
  add_op   |
  sub_op   |
  lshft_op |
  rshft_op |
  and_op   |
  bwand_op |
  or_op    |
  bwor_op  |
  bwxor_op |
  lt_eq_op  |
  lt_op    |
  gt_eq_op  |
  gt_op    |
  eq_op    |
  neq_op   |
  elect_op
}

// Literals
literal = _{
  int_literal   |
  float_literal |
  str_literal   |
  bool_literal  |
  const_literal
}

bool_true    = { "true" }
bool_false   = { "false" }

str_literal  = { qwt ~ (escape | raw_str)* ~ qwt }
char_literal = { sqwt ~ (!"'" ~ (escape | raw_char)) ~ sqwt }

raw_str    = { (!("\"" | "\\") ~ any)+  }
raw_char   = { any }

/// Types
string = { (keyword_cn | keyword_vl)? ~ (prim_type | symbol ) ~ ptr_op* ~ idx* }

char_type = { "char" }
void_type = { "void" }
str_type  = { "str"  }
bool_type = { "bool" }
i8_type   = { "i8" }
u8_type   = { "u8" }
i16_type  = { "i16" }
u16_type  = { "u16" }
i32_type  = { "i32" }
u32_type  = { "u32" }
i64_type  = { "i64" }
u64_type  = { "u64" }
f32_type  = { "f32" }
f64_type  = { "f64" }

// Primitive
prim_type = {
  void_type |
  str_type  |
  char_type |
  bool_type |
  i8_type   |
  u8_type   |
  i16_type  |
  u16_type  |
  i32_type  |
  u32_type  |
  i64_type  |
  u64_type  |
  f32_type  |
  f64_type
}

// Primary expression
pexp = { ident_literal | num_literals | str_literal | char_literal | (lparen ~ exp ~ rparen)}

// Prefix expression
pfexp = { pexp ~
  ( params
    | (lsq ~ exp ~ rsq)
    | (lsq ~ int ~ comma ~ int ~ rsq)
    | (dot ~ ident_literal)
    | (inc_op | dec_op)
  )*
}

// Unary expression
uexp = { pfexp
       | ((inc_op | dec_op) ~ uexp)
       | (elops ~ cast)
       | ((keyword_szo | keyword_typ) ~ (uexp | cast_op ~ string))
}

cast  = { (cast_op ~ string)? ~ uexp }
mult_exp  = { cast ~ ((mult_op | div_op | mod_op) ~ cast)* } // multiplicative expression
add_exp  = { mult_exp ~ ((add_op | sub_op) ~ mult_exp)* } // addition expression
shft_exp  = { add_exp ~ ((lshft_op | rshft_op) ~ add_exp)* } // shift expresion

rel_exp  = { shft_exp ~ ((lt_eq_op | gt_eq_op | lt_op | gt_op) ~ shft_exp)* } // relation expression
eq_exp  = { rel_exp ~ ((eq_op | neq_op) ~ rel_exp)* } // equivalence expression

cond_exp = { bool_exp ~(expoll_op ~ bool_exp ~ comma ~ bool_exp)* } // conditional expression
bw_exp = { eq_exp ~ ((bwor_op | bwxor_op | bwand_op) ~ eq_exp)* } // bit-wise expression
bool_exp  = { bw_exp ~ ((and_op | or_op) ~ bw_exp)* } // boolean expression
asgn_exp = { cond_exp ~ (elops ~ asgn_exp)* } // assignment expression

exp   = { asgn_exp ~ (comma ~ asgn_exp)* } // expression : generic

// Parameters
params = { lparen ~ (cond_exp ~ (comma ~ cond_exp)*)? ~ rparen }

// List of all elect operators
elops = {
  plus_elect_op   |
  minus_elect_op  |
  multi_elect_op  |
  mod_elect_op    |
  lshft_elect_op  |
  rshft_elect_op  |
  bw_and_elect_op |
  bw_or_elect_op  |
  bw_xor_elect_op |
  elect_op
}

// TODO: fix expression
unary_plus  = ${ plus ~ exp }
unary_minus = ${ minus ~ exp }

// List of unary operators
uops = {
  bwcom_op  |
  addr_op    |
  deref_op   |
  not_op |
  unary_plus |
  unary_minus
}

// numbers
int_zero_literal = { "0" }
int_decimal_literal = @{ digit_nonzero ~ int }
int_binary_literal = @{ int_binary_sigil ~ int_binary_number }
int_binary_sigil = _{ "0b" | "0B" }
int_binary_number = @{ (digit | "_")+ }
int_octal_literal = @{ int_octal_sigil ~ ('1'..'7') ~ ('0'..'7' | "_")* }
int_octal_sigil = _{ "0o" | "0O" }
int_hexadecimal_literal = @{ int_hexadecimal_sigil ~ (int | alpha )+ }
int_hexadecimal_sigil = _{ "0x" | "0X"}

int_literal = _{
  int_hexadecimal_literal |
  int_octal_literal |
  int_binary_literal |
  int_decimal_literal |
  int_zero_literal
}

expo        = @{ ("E" | "e") ~ (plus | minus)? ~ int } // exponent
int         = { digit ~ (digit | "_")* }
digit       = _{ '0'..'9' }
digit_nonzero = _{ '1'..'9' }
digit_octal   = { '0'..'7' }

float_literal = @{ (plus | minus)? ~ float_pfx ~ "." ~ (float_sfx ~ expo? | expo)? }
float_pfx = @{ ( "0" | ( '1'..'9' ~ ( '0'..'9' | "_" )* ) ) }
float_sfx = @{ ( "0" | ( '0'..'9' | "_" )+ ) }

num_literals   = { int | float_literal }

// Boolean
bool_literal = { bool_true | bool_false }

// silent details
newline       = _{ "\n" | "\r\n" }
whitespace    = _{ " " | "\t" | "\u{00C}" | newline }
block_comment = @{ "/*" ~ (!"*/" ~ any)* ~ "*/" }
line_comment  = @{ "//" ~ (!newline ~ any)* }
comment       = ${ block_comment | line_comment }

// trivia
hex      = { '0'..'9' | 'a'..'f' |'A'..'F' }
unicode = @{ "u" ~ hex{1, 4} }

escape = ${ "\\" ~ ("n" | "t" | "v" | "b" | "r" | "f" | "a" | "\\" | "?" | "'" | "\"") | octal_escape | hex_escape | unicode_escape }
octal_escape = ${ "\\" ~ digit_octal ~ digit_octal? ~ digit_octal? }
hex_escape = ${ "\\" ~ "x" ~ hex{2}? }
unicode_escape = ${ "\\" ~ "u" ~ hex{1, 4} }

symbol   = { (ident_literal ~ dot)? ~ ident_literal }

property_access = @{ "@" ~ ident_literal }
local_var_access = { ident_literal }

idx      = { lsq ~ ( arr_inc_op | exp )? ~ rsq } // index
constant = { keyword_nil | ident_literal | num_literals | str_literal | char_literal }
